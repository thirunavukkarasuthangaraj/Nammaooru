import { Injectable } from '@angular/core';
import { Observable, BehaviorSubject, Subject } from 'rxjs';
import { environment } from '../../../environments/environment';
import { Client, StompConfig } from '@stomp/stompjs';

export interface WebSocketMessage {
  type: string;
  payload: any;
  timestamp: Date;
}

@Injectable({
  providedIn: 'root'
})
export class WebSocketService {
  private stompClient: Client | null = null;
  private connectionStatus$ = new BehaviorSubject<boolean>(false);
  private messageSubjects: Map<string, Subject<any>> = new Map();
  
  private reconnectInterval = 5000; // 5 seconds
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 10;

  constructor() {}

  /**
   * Connect to WebSocket server
   */
  connect(token?: string): Observable<boolean> {
    const serverUrl = `${environment.apiUrl}/ws`;
    const ws = new SockJS(serverUrl);
    this.stompClient = Stomp.over(ws);
    
    // Disable debug output in production
    if (environment.production) {
      this.stompClient.debug = null;
    }

    const headers = token ? { Authorization: `Bearer ${token}` } : {};

    return new Observable(observer => {
      this.stompClient.connect(headers, 
        (frame: any) => {
          console.log('WebSocket Connected:', frame);
          this.connectionStatus$.next(true);
          this.reconnectAttempts = 0;
          observer.next(true);
          observer.complete();
        },
        (error: any) => {
          console.error('WebSocket Connection Error:', error);
          this.connectionStatus$.next(false);
          observer.error(error);
          this.handleReconnect(token);
        }
      );
    });
  }

  /**
   * Disconnect from WebSocket server
   */
  disconnect(): void {
    if (this.stompClient && this.stompClient.connected) {
      this.stompClient.disconnect(() => {
        console.log('WebSocket Disconnected');
        this.connectionStatus$.next(false);
      });
    }
    this.messageSubjects.clear();
  }

  /**
   * Subscribe to a topic/queue
   */
  subscribe(destination: string): Observable<any> {
    if (!this.messageSubjects.has(destination)) {
      const subject = new Subject<any>();
      this.messageSubjects.set(destination, subject);

      if (this.isConnected()) {
        this.stompClient.subscribe(destination, (message: any) => {
          const body = JSON.parse(message.body);
          subject.next(body);
        });
      }
    }

    return this.messageSubjects.get(destination)!.asObservable();
  }

  /**
   * Send message to destination
   */
  send(destination: string, body: any): void {
    if (this.isConnected()) {
      this.stompClient.send(destination, {}, JSON.stringify(body));
    } else {
      console.error('WebSocket not connected. Cannot send message.');
    }
  }

  /**
   * Check connection status
   */
  isConnected(): boolean {
    return this.stompClient && this.stompClient.connected;
  }

  /**
   * Get connection status observable
   */
  getConnectionStatus(): Observable<boolean> {
    return this.connectionStatus$.asObservable();
  }

  /**
   * Handle automatic reconnection
   */
  private handleReconnect(token?: string): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached');
      return;
    }

    this.reconnectAttempts++;
    console.log(`Reconnecting... Attempt ${this.reconnectAttempts}`);

    setTimeout(() => {
      this.connect(token).subscribe({
        next: () => console.log('Reconnected successfully'),
        error: () => console.error('Reconnection failed')
      });
    }, this.reconnectInterval);
  }

  // Delivery-specific methods

  /**
   * Subscribe to tracking updates for an assignment
   */
  subscribeToTracking(assignmentId: number): Observable<any> {
    return this.subscribe(`/topic/tracking/assignment/${assignmentId}`);
  }

  /**
   * Subscribe to delivery status updates
   */
  subscribeToDeliveryStatus(assignmentId: number): Observable<any> {
    return this.subscribe(`/topic/delivery/status/${assignmentId}`);
  }

  /**
   * Subscribe to partner's new assignments
   */
  subscribeToPartnerAssignments(partnerId: number): Observable<any> {
    return this.subscribe(`/queue/partner/${partnerId}/new-assignment`);
  }

  /**
   * Subscribe to partner messages
   */
  subscribeToPartnerMessages(partnerId: number): Observable<any> {
    return this.subscribe(`/queue/partner/${partnerId}/message`);
  }

  /**
   * Subscribe to customer notifications
   */
  subscribeToCustomerNotifications(customerId: number): Observable<any> {
    return this.subscribe(`/queue/customer/${customerId}/notifications`);
  }

  /**
   * Subscribe to admin emergency alerts
   */
  subscribeToEmergencyAlerts(): Observable<any> {
    return this.subscribe('/topic/delivery/admin/emergency');
  }

  /**
   * Subscribe to system announcements
   */
  subscribeToAnnouncements(): Observable<any> {
    return this.subscribe('/topic/delivery/announcements');
  }

  /**
   * Subscribe to chat messages for an assignment
   */
  subscribeToChatMessages(assignmentId: number): Observable<any> {
    return this.subscribe(`/topic/delivery/chat/${assignmentId}`);
  }

  /**
   * Send location update
   */
  sendLocationUpdate(locationData: any): void {
    this.send('/app/delivery/location', locationData);
  }

  /**
   * Send delivery status update
   */
  sendStatusUpdate(statusData: any): void {
    this.send('/app/delivery/status', statusData);
  }

  /**
   * Send partner online status
   */
  sendOnlineStatus(partnerId: number, isOnline: boolean): void {
    this.send('/app/partner/online-status', { partnerId, isOnline });
  }

  /**
   * Send emergency alert
   */
  sendEmergencyAlert(emergencyData: any): void {
    this.send('/app/partner/emergency', emergencyData);
  }

  /**
   * Send chat message
   */
  sendChatMessage(assignmentId: number, message: string, senderType: string): void {
    this.send('/app/chat/send', {
      assignmentId,
      message,
      senderType,
      timestamp: new Date()
    });
  }

  /**
   * Send customer feedback
   */
  sendCustomerFeedback(assignmentId: number, rating: number, feedback: string): void {
    this.send('/app/customer/feedback', {
      assignmentId,
      rating,
      feedback,
      timestamp: new Date()
    });
  }
}