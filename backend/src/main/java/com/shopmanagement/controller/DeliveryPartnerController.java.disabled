package com.shopmanagement.controller;

import com.shopmanagement.entity.User;
import com.shopmanagement.entity.User.UserRole;
import com.shopmanagement.entity.User.RideStatus;
import com.shopmanagement.entity.OrderAssignment;
import com.shopmanagement.entity.DeliveryPartnerLocation;
import com.shopmanagement.service.UserService;
import com.shopmanagement.service.OrderAssignmentService;
import com.shopmanagement.service.JwtService;
import com.shopmanagement.service.FirebaseNotificationService;
import com.shopmanagement.service.EmergencyService;
import com.shopmanagement.repository.DeliveryPartnerLocationRepository;
import com.shopmanagement.entity.Emergency;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;
import lombok.extern.slf4j.Slf4j;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/mobile/delivery-partner")
@CrossOrigin(origins = "*")
@Slf4j
public class DeliveryPartnerController {

    @Autowired
    private UserService userService;

    @Autowired
    private OrderAssignmentService orderAssignmentService;

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private JwtService jwtService;

    @Autowired
    private DeliveryPartnerLocationRepository deliveryPartnerLocationRepository;

    @Autowired
    private FirebaseNotificationService firebaseNotificationService;

    @Autowired
    private EmergencyService emergencyService;

    @PostMapping("/login")
    @Transactional
    public ResponseEntity<Map<String, Object>> login(@RequestBody Map<String, String> request) {
        String email = request.get("email");
        String password = request.get("password");
        
        Map<String, Object> response = new HashMap<>();
        
        try {
            // Find user by email and check if they are a delivery partner
            Optional<User> userOpt = userService.findByEmail(email);
            
            if (userOpt.isEmpty()) {
                response.put("success", false);
                response.put("message", "User not found");
                return ResponseEntity.badRequest().body(response);
            }
            
            User user = userOpt.get();
            
            // Check if user is a delivery partner
            if (user.getRole() != UserRole.DELIVERY_PARTNER) {
                response.put("success", false);
                response.put("message", "Access denied. Not a delivery partner account.");
                return ResponseEntity.badRequest().body(response);
            }
            
            // Check if user is active
            if (!user.getIsActive()) {
                response.put("success", false);
                response.put("message", "Account is disabled. Contact support.");
                return ResponseEntity.badRequest().body(response);
            }
            
            // Check password: static "password123" for testing, or verify against encoded password
            boolean isValidPassword = "password123".equals(password);
            if (!isValidPassword) {
                // Check if password matches the encoded password in database
                isValidPassword = passwordEncoder.matches(password, user.getPassword());
            }

            // If still not valid, try Spring Security authentication as fallback
            if (!isValidPassword) {
                try {
                    Authentication authentication = authenticationManager.authenticate(
                        new UsernamePasswordAuthenticationToken(email, password)
                    );
                    isValidPassword = authentication.isAuthenticated();
                } catch (Exception e) {
                    isValidPassword = false;
                }
            }

            if (!isValidPassword) {
                response.put("success", false);
                response.put("message", "Invalid email or password");
                return ResponseEntity.badRequest().body(response);
            }
            
            // Generate proper JWT token
            String token = jwtService.generateToken(user);

            // Set delivery partner as online upon successful login
            user.setIsOnline(true);
            user.setIsAvailable(true);
            user.setRideStatus(User.RideStatus.AVAILABLE);
            user.setLastLogin(LocalDateTime.now());
            user.setLastActivity(LocalDateTime.now());
            userService.save(user);

            System.out.println("Delivery partner " + user.getEmail() + " logged in and set to online");
            
            response.put("success", true);
            response.put("message", "Login successful");
            response.put("token", token);
            response.put("partnerId", user.getId().toString());
            response.put("requiresPasswordChange", user.getPasswordChangeRequired());
            response.put("isFirstTimeLogin", user.getIsTemporaryPassword());
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Invalid email or password");
            return ResponseEntity.badRequest().body(response);
        }
    }

    @GetMapping("/profile/{partnerId}")
    public ResponseEntity<Map<String, Object>> getProfile(@PathVariable String partnerId) {
        try {
            Long id = Long.parseLong(partnerId);
            Optional<User> userOpt = userService.findById(id);
            
            if (userOpt.isEmpty()) {
                Map<String, Object> response = new HashMap<>();
                response.put("success", false);
                response.put("message", "User not found");
                return ResponseEntity.badRequest().body(response);
            }
            
            User user = userOpt.get();
            
            // Check if user is a delivery partner
            if (user.getRole() != UserRole.DELIVERY_PARTNER) {
                Map<String, Object> response = new HashMap<>();
                response.put("success", false);
                response.put("message", "Access denied");
                return ResponseEntity.badRequest().body(response);
            }
            
            Map<String, Object> profile = new HashMap<>();
            profile.put("partnerId", user.getId());

            // Handle null names properly
            String firstName = user.getFirstName() != null ? user.getFirstName() : "Delivery";
            String lastName = user.getLastName() != null ? user.getLastName() : "Partner";
            profile.put("name", firstName + " " + lastName);

            profile.put("email", user.getEmail());
            profile.put("phoneNumber", user.getMobileNumber());
            profile.put("isOnline", true); // Default for now
            profile.put("isAvailable", true); // Default for now
            profile.put("success", true);
            
            return ResponseEntity.ok(profile);
            
        } catch (NumberFormatException e) {
            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", "Invalid partner ID");
            return ResponseEntity.badRequest().body(response);
        }
    }
    
    @GetMapping("/orders/{partnerId}/available")
    @Transactional(readOnly = true)
    public ResponseEntity<Map<String, Object>> getAvailableOrders(@PathVariable String partnerId) {
        Map<String, Object> response = new HashMap<>();

        try {
            Long id = Long.parseLong(partnerId);

            // Get pending assignments for this partner that are in ASSIGNED status
            List<OrderAssignment> availableAssignments = orderAssignmentService.findPendingAssignmentsByPartnerId(id);

            // Convert to order format for the app
            List<Map<String, Object>> orders = new ArrayList<>();
            for (OrderAssignment assignment : availableAssignments) {
                if (assignment.getStatus() == OrderAssignment.AssignmentStatus.ASSIGNED) {
                    Map<String, Object> orderData = new HashMap<>();
                    orderData.put("id", assignment.getId().toString());
                    orderData.put("orderNumber", assignment.getOrder().getOrderNumber());
                    orderData.put("totalAmount", assignment.getOrder().getTotalAmount());
                    orderData.put("deliveryFee", assignment.getDeliveryFee());
                    orderData.put("status", assignment.getStatus().name());
                    orderData.put("createdAt", assignment.getCreatedAt().toString());
                    orderData.put("deliveryAddress", assignment.getOrder().getDeliveryAddress());
                    orderData.put("customerName", assignment.getOrder().getCustomer().getFirstName() + " " + assignment.getOrder().getCustomer().getLastName());
                    orderData.put("customerPhone", assignment.getOrder().getCustomer().getMobileNumber());
                    orderData.put("shopName", assignment.getOrder().getShop().getName());
                    orderData.put("shopAddress", assignment.getOrder().getShop().getAddressLine1());
                    orderData.put("paymentMethod", assignment.getOrder().getPaymentMethod().name());
                    orderData.put("paymentStatus", assignment.getOrder().getPaymentStatus().name());
                    orders.add(orderData);
                }
            }

            response.put("orders", orders);
            response.put("totalCount", orders.size());
            response.put("success", true);
            if (orders.isEmpty()) {
                response.put("message", "No available orders at the moment");
            }

        } catch (Exception e) {
            response.put("orders", new ArrayList<>());
            response.put("totalCount", 0);
            response.put("success", false);
            response.put("message", "Error fetching orders: " + e.getMessage());
        }

        return ResponseEntity.ok(response);
    }

    @GetMapping("/orders/{partnerId}/active")
    @Transactional(readOnly = true)
    public ResponseEntity<Map<String, Object>> getActiveOrders(@PathVariable String partnerId) {
        Map<String, Object> response = new HashMap<>();

        try {
            Long id = Long.parseLong(partnerId);

            // Get current active assignment for this partner
            Optional<OrderAssignment> currentAssignment = orderAssignmentService.findCurrentAssignmentByPartnerId(id);

            List<Map<String, Object>> orders = new ArrayList<>();
            if (currentAssignment.isPresent()) {
                OrderAssignment assignment = currentAssignment.get();
                // Only show if status is ACCEPTED, PICKED_UP, or IN_TRANSIT
                if (assignment.getStatus() == OrderAssignment.AssignmentStatus.ACCEPTED ||
                    assignment.getStatus() == OrderAssignment.AssignmentStatus.PICKED_UP ||
                    assignment.getStatus() == OrderAssignment.AssignmentStatus.IN_TRANSIT) {

                    Map<String, Object> orderData = new HashMap<>();
                    orderData.put("id", assignment.getId().toString());
                    orderData.put("orderNumber", assignment.getOrder().getOrderNumber());
                    orderData.put("totalAmount", assignment.getOrder().getTotalAmount());
                    orderData.put("deliveryFee", assignment.getDeliveryFee());
                    orderData.put("status", assignment.getStatus().name());
                    orderData.put("createdAt", assignment.getCreatedAt().toString());
                    orderData.put("deliveryAddress", assignment.getOrder().getDeliveryAddress());
                    orderData.put("customerName", assignment.getOrder().getCustomer().getFirstName() + " " + assignment.getOrder().getCustomer().getLastName());
                    orderData.put("customerPhone", assignment.getOrder().getCustomer().getMobileNumber());
                    orderData.put("shopName", assignment.getOrder().getShop().getName());
                    orderData.put("shopAddress", assignment.getOrder().getShop().getAddressLine1());
                    orderData.put("paymentMethod", assignment.getOrder().getPaymentMethod().name());
                    orderData.put("paymentStatus", assignment.getOrder().getPaymentStatus().name());
                    orders.add(orderData);
                }
            }

            response.put("orders", orders);
            response.put("totalCount", orders.size());
            response.put("success", true);

        } catch (Exception e) {
            log.error("Error fetching active orders for partner {}: {}", partnerId, e.getMessage(), e);
            response.put("orders", new ArrayList<>());
            response.put("totalCount", 0);
            response.put("success", false);
            response.put("message", "Error fetching active orders: " + e.getMessage());
        }

        return ResponseEntity.ok(response);
    }

    @GetMapping("/leaderboard")
    public ResponseEntity<Map<String, Object>> getLeaderboard() {
        // For now, return empty list - this will be implemented later
        Map<String, Object> response = new HashMap<>();
        response.put("leaderboard", new java.util.ArrayList<>());
        response.put("message", "Leaderboard functionality implemented");
        response.put("success", true);
        
        return ResponseEntity.ok(response);
    }
    
    @PostMapping("/status/{partnerId}")
    public ResponseEntity<Map<String, Object>> updateOnlineStatus(@PathVariable String partnerId, @RequestBody Map<String, Object> request) {
        Map<String, Object> response = new HashMap<>();

        try {
            Long id = Long.parseLong(partnerId);
            Optional<User> userOpt = userService.findById(id);

            if (userOpt.isEmpty()) {
                response.put("success", false);
                response.put("message", "User not found");
                return ResponseEntity.badRequest().body(response);
            }

            User user = userOpt.get();

            // Check if user is a delivery partner
            if (user.getRole() != UserRole.DELIVERY_PARTNER) {
                response.put("success", false);
                response.put("message", "Access denied");
                return ResponseEntity.badRequest().body(response);
            }

            // Update online status
            Boolean isOnline = (Boolean) request.get("isOnline");
            Boolean isAvailable = (Boolean) request.get("isAvailable");
            String rideStatus = (String) request.get("rideStatus");

            if (isOnline != null) {
                user.setIsOnline(isOnline);
                if (isOnline) {
                    user.setLastActivity(LocalDateTime.now());
                }
            }

            if (isAvailable != null) {
                user.setIsAvailable(isAvailable);
            }

            if (rideStatus != null) {
                try {
                    User.RideStatus status = User.RideStatus.valueOf(rideStatus);
                    user.setRideStatus(status);
                } catch (IllegalArgumentException e) {
                    // Invalid ride status, ignore
                }
            }

            userService.save(user);

            response.put("success", true);
            response.put("message", "Status updated successfully");
            response.put("isOnline", user.getIsOnline());
            response.put("isAvailable", user.getIsAvailable());
            response.put("rideStatus", user.getRideStatus().name());

            return ResponseEntity.ok(response);

        } catch (NumberFormatException e) {
            response.put("success", false);
            response.put("message", "Invalid partner ID");
            return ResponseEntity.badRequest().body(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "An error occurred while updating status");
            return ResponseEntity.badRequest().body(response);
        }
    }

    @PostMapping("/forgot-password")
    public ResponseEntity<Map<String, Object>> forgotPassword(@RequestBody Map<String, String> request) {
        String email = request.get("email");
        Map<String, Object> response = new HashMap<>();

        try {
            if (email == null || email.trim().isEmpty()) {
                response.put("success", false);
                response.put("message", "Email is required");
                return ResponseEntity.badRequest().body(response);
            }

            // Find user by email and check if they are a delivery partner
            Optional<User> userOpt = userService.findByEmail(email);

            if (userOpt.isEmpty()) {
                response.put("success", false);
                response.put("message", "No delivery partner found with this email address");
                return ResponseEntity.badRequest().body(response);
            }

            User user = userOpt.get();

            // Check if user is a delivery partner
            if (user.getRole() != UserRole.DELIVERY_PARTNER) {
                response.put("success", false);
                response.put("message", "This email is not associated with a delivery partner account");
                return ResponseEntity.badRequest().body(response);
            }

            // Check if user is active
            if (!user.getIsActive()) {
                response.put("success", false);
                response.put("message", "Account is disabled. Contact support.");
                return ResponseEntity.badRequest().body(response);
            }

            // Generate a simple temporary password (in production, use proper reset tokens)
            String tempPassword = "temp123" + System.currentTimeMillis() % 1000;
            String encodedTempPassword = passwordEncoder.encode(tempPassword);

            // Update user with temporary password
            user.setPassword(encodedTempPassword);
            user.setPasswordChangeRequired(true);
            user.setIsTemporaryPassword(true);
            userService.save(user);

            // In a real application, you would send this via email
            // For now, return it in the response for testing
            response.put("success", true);
            response.put("message", "Temporary password has been generated. Please use it to log in and change your password.");
            response.put("temporaryPassword", tempPassword); // Remove this in production!

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "An error occurred while processing your request");
            return ResponseEntity.badRequest().body(response);
        }
    }

    @PutMapping("/change-password")
    public ResponseEntity<Map<String, Object>> changePassword(@RequestBody Map<String, String> request) {
        String partnerId = request.get("partnerId");
        String currentPassword = request.get("currentPassword");
        String newPassword = request.get("newPassword");
        
        Map<String, Object> response = new HashMap<>();
        
        try {
            if (partnerId == null || currentPassword == null || newPassword == null) {
                response.put("success", false);
                response.put("message", "Missing required fields");
                return ResponseEntity.badRequest().body(response);
            }
            
            Long id = Long.parseLong(partnerId);
            Optional<User> userOpt = userService.findById(id);
            
            if (userOpt.isEmpty()) {
                response.put("success", false);
                response.put("message", "User not found");
                return ResponseEntity.badRequest().body(response);
            }
            
            User user = userOpt.get();
            
            // Check if user is a delivery partner
            if (user.getRole() != UserRole.DELIVERY_PARTNER) {
                response.put("success", false);
                response.put("message", "Access denied");
                return ResponseEntity.badRequest().body(response);
            }
            
            // Verify current password
            if (!passwordEncoder.matches(currentPassword, user.getPassword())) {
                response.put("success", false);
                response.put("message", "Current password is incorrect");
                return ResponseEntity.badRequest().body(response);
            }
            
            // Update password
            user.setPassword(passwordEncoder.encode(newPassword));
            user.setPasswordChangeRequired(false);
            user.setIsTemporaryPassword(false);
            userService.save(user);
            
            response.put("success", true);
            response.put("message", "Password changed successfully");
            
            return ResponseEntity.ok(response);
            
        } catch (NumberFormatException e) {
            response.put("success", false);
            response.put("message", "Invalid partner ID");
            return ResponseEntity.badRequest().body(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "An error occurred while changing password");
            return ResponseEntity.badRequest().body(response);
        }
    }

    // Real-time Status Tracking Endpoints

    @PutMapping("/update-location/{partnerId}")
    public ResponseEntity<Map<String, Object>> updateLocation(@PathVariable String partnerId, @RequestBody Map<String, Object> request) {
        Map<String, Object> response = new HashMap<>();

        try {
            Long id = Long.parseLong(partnerId);
            Optional<User> userOpt = userService.findById(id);

            if (userOpt.isEmpty()) {
                response.put("success", false);
                response.put("message", "User not found");
                return ResponseEntity.badRequest().body(response);
            }

            User user = userOpt.get();

            if (user.getRole() != UserRole.DELIVERY_PARTNER) {
                response.put("success", false);
                response.put("message", "Access denied");
                return ResponseEntity.badRequest().body(response);
            }

            // Extract location data
            Double latitude = ((Number) request.get("latitude")).doubleValue();
            Double longitude = ((Number) request.get("longitude")).doubleValue();
            Double accuracy = request.get("accuracy") != null ? ((Number) request.get("accuracy")).doubleValue() : null;
            Double speed = request.get("speed") != null ? ((Number) request.get("speed")).doubleValue() : null;
            Double heading = request.get("heading") != null ? ((Number) request.get("heading")).doubleValue() : null;
            Double altitude = request.get("altitude") != null ? ((Number) request.get("altitude")).doubleValue() : null;
            Integer batteryLevel = request.get("batteryLevel") != null ? ((Number) request.get("batteryLevel")).intValue() : null;
            String networkType = (String) request.get("networkType");
            Long assignmentId = request.get("assignmentId") != null ? ((Number) request.get("assignmentId")).longValue() : null;
            String orderStatus = (String) request.get("orderStatus");

            // Update User entity (for backward compatibility)
            user.setCurrentLatitude(latitude);
            user.setCurrentLongitude(longitude);
            user.setLastLocationUpdate(LocalDateTime.now());
            user.setLastActivity(LocalDateTime.now());
            userService.save(user);

            // Save detailed location tracking
            DeliveryPartnerLocation location = DeliveryPartnerLocation.builder()
                    .partnerId(id)
                    .latitude(BigDecimal.valueOf(latitude))
                    .longitude(BigDecimal.valueOf(longitude))
                    .accuracy(accuracy != null ? BigDecimal.valueOf(accuracy) : null)
                    .speed(speed != null ? BigDecimal.valueOf(speed) : null)
                    .heading(heading != null ? BigDecimal.valueOf(heading) : null)
                    .altitude(altitude != null ? BigDecimal.valueOf(altitude) : null)
                    .batteryLevel(batteryLevel)
                    .networkType(networkType)
                    .assignmentId(assignmentId)
                    .orderStatus(orderStatus)
                    .recordedAt(LocalDateTime.now())
                    .isMoving(speed != null && speed > 1.0)
                    .build();

            deliveryPartnerLocationRepository.save(location);

            // Maintain only latest 5 records per partner
            try {
                deliveryPartnerLocationRepository.deleteOldLocationsKeepingLatest(id, 5);
            } catch (Exception e) {
                log.warn("Failed to cleanup old location records for partner {}: {}", id, e.getMessage());
            }

            response.put("success", true);
            response.put("message", "Location updated successfully");
            response.put("timestamp", LocalDateTime.now().toString());

            return ResponseEntity.ok(response);

        } catch (NumberFormatException e) {
            response.put("success", false);
            response.put("message", "Invalid partner ID or coordinates");
            return ResponseEntity.badRequest().body(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "An error occurred while updating location");
            return ResponseEntity.badRequest().body(response);
        }
    }

    @PutMapping("/update-ride-status/{partnerId}")
    public ResponseEntity<Map<String, Object>> updateRideStatus(@PathVariable String partnerId, @RequestBody Map<String, Object> request) {
        Map<String, Object> response = new HashMap<>();

        try {
            Long id = Long.parseLong(partnerId);
            Optional<User> userOpt = userService.findById(id);

            if (userOpt.isEmpty()) {
                response.put("success", false);
                response.put("message", "User not found");
                return ResponseEntity.badRequest().body(response);
            }

            User user = userOpt.get();

            if (user.getRole() != UserRole.DELIVERY_PARTNER) {
                response.put("success", false);
                response.put("message", "Access denied");
                return ResponseEntity.badRequest().body(response);
            }

            // Update ride status
            String rideStatusStr = (String) request.get("rideStatus");
            RideStatus rideStatus = RideStatus.valueOf(rideStatusStr);

            user.setRideStatus(rideStatus);
            user.setLastActivity(LocalDateTime.now());

            // Auto-update availability and online status based on ride status
            if (rideStatus == RideStatus.OFFLINE) {
                user.setIsOnline(false);
                user.setIsAvailable(false);
            } else if (rideStatus == RideStatus.AVAILABLE) {
                user.setIsOnline(true);
                user.setIsAvailable(true);
            } else {
                user.setIsOnline(true);
                user.setIsAvailable(false);
            }

            userService.save(user);

            response.put("success", true);
            response.put("message", "Ride status updated successfully");
            response.put("rideStatus", rideStatus);
            response.put("isOnline", user.getIsOnline());
            response.put("isAvailable", user.getIsAvailable());

            return ResponseEntity.ok(response);

        } catch (IllegalArgumentException e) {
            response.put("success", false);
            response.put("message", "Invalid ride status");
            return ResponseEntity.badRequest().body(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "An error occurred while updating ride status");
            return ResponseEntity.badRequest().body(response);
        }
    }

    @GetMapping("/online-partners")
    public ResponseEntity<Map<String, Object>> getOnlinePartners() {
        try {
            List<User> onlinePartners = userService.findByRoleAndIsOnline(UserRole.DELIVERY_PARTNER, true);

            List<Map<String, Object>> partnersList = onlinePartners.stream()
                .map(partner -> {
                    Map<String, Object> partnerInfo = new HashMap<>();
                    partnerInfo.put("partnerId", partner.getId());
                    partnerInfo.put("name", partner.getFullName());
                    partnerInfo.put("email", partner.getEmail());
                    partnerInfo.put("isOnline", partner.getIsOnline());
                    partnerInfo.put("isAvailable", partner.getIsAvailable());
                    partnerInfo.put("rideStatus", partner.getRideStatus());
                    partnerInfo.put("currentLatitude", partner.getCurrentLatitude());
                    partnerInfo.put("currentLongitude", partner.getCurrentLongitude());
                    partnerInfo.put("lastLocationUpdate", partner.getLastLocationUpdate());
                    partnerInfo.put("lastActivity", partner.getLastActivity());
                    return partnerInfo;
                })
                .collect(Collectors.toList());

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("partners", partnersList);
            response.put("totalCount", partnersList.size());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", "An error occurred while fetching online partners");
            return ResponseEntity.badRequest().body(response);
        }
    }

    @GetMapping("/all-partners-status")
    public ResponseEntity<Map<String, Object>> getAllPartnersStatus() {
        try {
            List<User> allPartners = userService.findByRole(UserRole.DELIVERY_PARTNER);

            List<Map<String, Object>> partnersList = allPartners.stream()
                .map(partner -> {
                    Map<String, Object> partnerInfo = new HashMap<>();
                    partnerInfo.put("partnerId", partner.getId());
                    partnerInfo.put("name", partner.getFullName());
                    partnerInfo.put("email", partner.getEmail());
                    partnerInfo.put("isActive", partner.getIsActive());
                    partnerInfo.put("isOnline", partner.getIsOnline());
                    partnerInfo.put("isAvailable", partner.getIsAvailable());
                    partnerInfo.put("rideStatus", partner.getRideStatus());
                    partnerInfo.put("lastActivity", partner.getLastActivity());
                    partnerInfo.put("lastLogin", partner.getLastLogin());
                    return partnerInfo;
                })
                .collect(Collectors.toList());

            // Group partners by status for dashboard
            Map<String, Long> statusCounts = new HashMap<>();
            statusCounts.put("online", partnersList.stream().filter(p -> Boolean.TRUE.equals(p.get("isOnline"))).count());
            statusCounts.put("offline", partnersList.stream().filter(p -> Boolean.FALSE.equals(p.get("isOnline"))).count());
            statusCounts.put("available", partnersList.stream().filter(p -> Boolean.TRUE.equals(p.get("isAvailable"))).count());
            statusCounts.put("busy", partnersList.stream().filter(p -> RideStatus.BUSY.equals(p.get("rideStatus")) || RideStatus.ON_RIDE.equals(p.get("rideStatus"))).count());

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("partners", partnersList);
            response.put("totalCount", partnersList.size());
            response.put("statusCounts", statusCounts);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", "An error occurred while fetching partners status");
            return ResponseEntity.badRequest().body(response);
        }
    }

    // Order Accept/Reject endpoints for mobile app
    @PostMapping("/orders/{orderId}/accept")
    @Transactional
    public ResponseEntity<Map<String, Object>> acceptOrder(@PathVariable String orderId, @RequestBody Map<String, Object> request) {
        Map<String, Object> response = new HashMap<>();

        try {
            Long partnerId = Long.parseLong(request.get("partnerId").toString());

            // Find the assignment by order number and partnerId
            List<OrderAssignment> assignments = orderAssignmentService.findAssignmentsByOrderNumber(orderId);
            OrderAssignment assignment = assignments.stream()
                .filter(a -> a.getDeliveryPartner().getId().equals(partnerId) &&
                           a.getStatus() == OrderAssignment.AssignmentStatus.ASSIGNED)
                .findFirst()
                .orElseThrow(() -> new RuntimeException("No pending assignment found for this order and partner"));

            // Accept the assignment
            OrderAssignment acceptedAssignment = orderAssignmentService.acceptAssignment(assignment.getId(), partnerId);

            response.put("success", true);
            response.put("message", "Order accepted successfully");
            response.put("assignmentId", acceptedAssignment.getId());
            response.put("orderNumber", acceptedAssignment.getOrder().getOrderNumber());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error accepting order: " + e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @PostMapping("/orders/{orderId}/reject")
    @Transactional
    public ResponseEntity<Map<String, Object>> rejectOrder(@PathVariable String orderId, @RequestBody Map<String, Object> request) {
        Map<String, Object> response = new HashMap<>();

        try {
            Long partnerId = Long.parseLong(request.get("partnerId").toString());
            String reason = request.containsKey("reason") ? request.get("reason").toString() : "No reason provided";

            // Find the assignment by order number and partnerId
            List<OrderAssignment> assignments = orderAssignmentService.findAssignmentsByOrderNumber(orderId);
            OrderAssignment assignment = assignments.stream()
                .filter(a -> a.getDeliveryPartner().getId().equals(partnerId) &&
                           a.getStatus() == OrderAssignment.AssignmentStatus.ASSIGNED)
                .findFirst()
                .orElseThrow(() -> new RuntimeException("No pending assignment found for this order and partner"));

            // Reject the assignment
            orderAssignmentService.rejectAssignment(assignment.getId(), partnerId, reason);

            response.put("success", true);
            response.put("message", "Order rejected successfully");

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error rejecting order: " + e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @PostMapping("/orders/{orderId}/pickup")
    @Transactional
    public ResponseEntity<Map<String, Object>> markOrderPickedUp(@PathVariable String orderId, @RequestBody Map<String, Object> request) {
        Map<String, Object> response = new HashMap<>();

        try {
            Long partnerId = Long.parseLong(request.get("partnerId").toString());

            // Find the assignment by order number and partnerId
            List<OrderAssignment> assignments = orderAssignmentService.findAssignmentsByOrderNumber(orderId);
            OrderAssignment assignment = assignments.stream()
                .filter(a -> a.getDeliveryPartner().getId().equals(partnerId) &&
                           a.getStatus() == OrderAssignment.AssignmentStatus.ACCEPTED)
                .findFirst()
                .orElseThrow(() -> new RuntimeException("No accepted assignment found for this order and partner"));

            // Mark as picked up
            OrderAssignment updatedAssignment = orderAssignmentService.markPickedUp(assignment.getId(), partnerId);

            response.put("success", true);
            response.put("message", "Order marked as picked up");

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error marking order as picked up: " + e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @PostMapping("/orders/{orderId}/deliver")
    @Transactional
    public ResponseEntity<Map<String, Object>> markOrderDelivered(@PathVariable String orderId, @RequestBody Map<String, Object> request) {
        Map<String, Object> response = new HashMap<>();

        try {
            Long partnerId = Long.parseLong(request.get("partnerId").toString());
            String deliveryNotes = request.containsKey("deliveryNotes") ? request.get("deliveryNotes").toString() : null;

            // Find the assignment by order number and partnerId
            List<OrderAssignment> assignments = orderAssignmentService.findAssignmentsByOrderNumber(orderId);
            OrderAssignment assignment = assignments.stream()
                .filter(a -> a.getDeliveryPartner().getId().equals(partnerId) &&
                           (a.getStatus() == OrderAssignment.AssignmentStatus.PICKED_UP ||
                            a.getStatus() == OrderAssignment.AssignmentStatus.IN_TRANSIT))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("No picked up or in-transit assignment found for this order and partner"));

            // Mark as delivered
            OrderAssignment updatedAssignment = orderAssignmentService.markDelivered(assignment.getId(), partnerId, deliveryNotes);

            response.put("success", true);
            response.put("message", "Order marked as delivered");

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error marking order as delivered: " + e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @GetMapping("/orders/{partnerId}/history")
    @Transactional(readOnly = true)
    public ResponseEntity<Map<String, Object>> getOrderHistory(@PathVariable String partnerId) {
        Map<String, Object> response = new HashMap<>();

        try {
            Long id = Long.parseLong(partnerId);

            // Get completed assignments for this partner (DELIVERED status)
            List<OrderAssignment> completedAssignments = orderAssignmentService.findAssignmentsByPartnerId(id,
                org.springframework.data.domain.Pageable.unpaged()).getContent()
                .stream()
                .filter(assignment -> assignment.getStatus() == OrderAssignment.AssignmentStatus.DELIVERED)
                .collect(Collectors.toList());

            List<Map<String, Object>> orders = new ArrayList<>();
            for (OrderAssignment assignment : completedAssignments) {
                Map<String, Object> orderData = new HashMap<>();
                orderData.put("id", assignment.getId().toString());
                orderData.put("orderNumber", assignment.getOrder().getOrderNumber());
                orderData.put("totalAmount", assignment.getOrder().getTotalAmount());
                orderData.put("deliveryFee", assignment.getDeliveryFee());
                orderData.put("status", assignment.getStatus().name());
                orderData.put("createdAt", assignment.getCreatedAt().toString());
                orderData.put("deliveryAddress", assignment.getOrder().getDeliveryAddress());
                orderData.put("customerName", assignment.getOrder().getCustomer().getFirstName() + " " + assignment.getOrder().getCustomer().getLastName());
                orderData.put("customerPhone", assignment.getOrder().getCustomer().getMobileNumber());
                orderData.put("shopName", assignment.getOrder().getShop().getName());
                orderData.put("shopAddress", assignment.getOrder().getShop().getAddressLine1());
                orderData.put("deliveredAt", assignment.getDeliveryCompletedAt() != null ? assignment.getDeliveryCompletedAt().toString() : null);
                orders.add(orderData);
            }

            response.put("orders", orders);
            response.put("totalCount", orders.size());
            response.put("success", true);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            response.put("orders", new ArrayList<>());
            response.put("totalCount", 0);
            response.put("success", false);
            response.put("message", "Error fetching order history: " + e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @GetMapping("/earnings/{partnerId}")
    @Transactional(readOnly = true)
    public ResponseEntity<Map<String, Object>> getEarnings(@PathVariable String partnerId, @RequestParam(required = false) String period) {
        Map<String, Object> response = new HashMap<>();

        try {
            Long id = Long.parseLong(partnerId);

            // Calculate earnings from completed assignments
            List<OrderAssignment> completedAssignments = orderAssignmentService.findAssignmentsByPartnerId(id,
                org.springframework.data.domain.Pageable.unpaged()).getContent()
                .stream()
                .filter(assignment -> assignment.getStatus() == OrderAssignment.AssignmentStatus.DELIVERED)
                .collect(Collectors.toList());

            double totalEarnings = completedAssignments.stream()
                .mapToDouble(assignment -> assignment.getPartnerCommission() != null ? assignment.getPartnerCommission().doubleValue() : 0.0)
                .sum();

            long totalDeliveries = completedAssignments.size();

            // Simple earnings calculation (can be enhanced with period filtering)
            Map<String, Object> earnings = new HashMap<>();
            earnings.put("todayEarnings", totalEarnings); // Simplified - shows total for now
            earnings.put("weeklyEarnings", totalEarnings);
            earnings.put("monthlyEarnings", totalEarnings);
            earnings.put("totalEarnings", totalEarnings);
            earnings.put("todayDeliveries", totalDeliveries);
            earnings.put("weeklyDeliveries", totalDeliveries);
            earnings.put("monthlyDeliveries", totalDeliveries);
            earnings.put("totalDeliveries", totalDeliveries);
            earnings.put("recentEarnings", new ArrayList<>());

            response.put("success", true);
            response.putAll(earnings);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error fetching earnings: " + e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    // Customer Order Tracking Endpoints

    @GetMapping("/track/order/{orderNumber}")
    public ResponseEntity<Map<String, Object>> trackOrderByOrderNumber(@PathVariable String orderNumber) {
        Map<String, Object> response = new HashMap<>();

        try {
            // Find order assignment by order number
            Optional<OrderAssignment> assignmentOpt = orderAssignmentService.findByOrderNumber(orderNumber);

            if (assignmentOpt.isEmpty()) {
                response.put("success", false);
                response.put("message", "Order not found or not assigned to delivery partner");
                return ResponseEntity.badRequest().body(response);
            }

            OrderAssignment assignment = assignmentOpt.get();

            // Get latest location for this assignment
            Optional<DeliveryPartnerLocation> latestLocation =
                deliveryPartnerLocationRepository.findLatestLocationByAssignmentId(assignment.getId());

            if (latestLocation.isEmpty()) {
                response.put("success", false);
                response.put("message", "Driver location not available");
                return ResponseEntity.badRequest().body(response);
            }

            DeliveryPartnerLocation location = latestLocation.get();

            // Build tracking response
            Map<String, Object> trackingData = new HashMap<>();
            trackingData.put("orderNumber", orderNumber);
            trackingData.put("assignmentId", assignment.getId());
            trackingData.put("deliveryStatus", assignment.getStatus().name());
            trackingData.put("partnerId", assignment.getDeliveryPartner().getId());
            trackingData.put("partnerName", assignment.getDeliveryPartner().getFullName());
            trackingData.put("partnerPhone", assignment.getDeliveryPartner().getMobileNumber());

            Map<String, Object> currentLocation = new HashMap<>();
            currentLocation.put("latitude", location.getLatitude());
            currentLocation.put("longitude", location.getLongitude());
            currentLocation.put("accuracy", location.getAccuracy());
            currentLocation.put("speed", location.getSpeed());
            currentLocation.put("heading", location.getHeading());
            currentLocation.put("isMoving", location.getIsMoving());
            currentLocation.put("lastUpdated", location.getRecordedAt());

            trackingData.put("currentLocation", currentLocation);

            // Add delivery address
            Map<String, Object> deliveryAddress = new HashMap<>();
            deliveryAddress.put("address", assignment.getOrder().getDeliveryAddress());
            // Add customer address coordinates if available
            // This would need to be implemented based on your address storage

            trackingData.put("deliveryAddress", deliveryAddress);

            response.put("success", true);
            response.put("tracking", trackingData);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Error tracking order {}: {}", orderNumber, e.getMessage(), e);
            response.put("success", false);
            response.put("message", "Error tracking order: " + e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @GetMapping("/track/assignment/{assignmentId}")
    public ResponseEntity<Map<String, Object>> trackOrderByAssignmentId(@PathVariable Long assignmentId) {
        Map<String, Object> response = new HashMap<>();

        try {
            // Get recent location history for this assignment
            List<DeliveryPartnerLocation> locationHistory =
                deliveryPartnerLocationRepository.findRecentLocationsByPartnerId(assignmentId, 5);

            if (locationHistory.isEmpty()) {
                response.put("success", false);
                response.put("message", "No location history found for this delivery");
                return ResponseEntity.badRequest().body(response);
            }

            List<Map<String, Object>> locations = locationHistory.stream()
                .map(loc -> {
                    Map<String, Object> locationData = new HashMap<>();
                    locationData.put("latitude", loc.getLatitude());
                    locationData.put("longitude", loc.getLongitude());
                    locationData.put("accuracy", loc.getAccuracy());
                    locationData.put("speed", loc.getSpeed());
                    locationData.put("heading", loc.getHeading());
                    locationData.put("isMoving", loc.getIsMoving());
                    locationData.put("timestamp", loc.getRecordedAt());
                    return locationData;
                })
                .collect(Collectors.toList());

            response.put("success", true);
            response.put("locationHistory", locations);
            response.put("totalPoints", locations.size());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Error getting location history for assignment {}: {}", assignmentId, e.getMessage(), e);
            response.put("success", false);
            response.put("message", "Error getting location history: " + e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @PostMapping("/verify-pickup-otp")
    @Transactional
    public ResponseEntity<Map<String, Object>> verifyPickupOtp(@RequestBody Map<String, Object> request) {
        Map<String, Object> response = new HashMap<>();

        try {
            Long orderId = Long.valueOf(request.get("orderId").toString());
            String otpCode = request.get("otp").toString();
            String partnerId = request.get("partnerId").toString();

            log.info("OTP verification request - Order: {}, Partner: {}, OTP: {}", orderId, partnerId, otpCode);

            // Find the order assignment
            Optional<OrderAssignment> assignmentOpt = orderAssignmentService.findByOrderId(orderId);
            if (assignmentOpt.isEmpty()) {
                response.put("success", false);
                response.put("message", "Order assignment not found");
                return ResponseEntity.badRequest().body(response);
            }

            OrderAssignment assignment = assignmentOpt.get();

            // Verify the partner ID matches
            if (!assignment.getDeliveryPartner().getId().toString().equals(partnerId)) {
                response.put("success", false);
                response.put("message", "Unauthorized: Order not assigned to this partner");
                return ResponseEntity.badRequest().body(response);
            }

            // Check if order is in correct status for pickup
            if (!"ACCEPTED".equals(assignment.getStatus()) && !"ASSIGNED".equals(assignment.getStatus())) {
                response.put("success", false);
                response.put("message", "Order is not in correct status for pickup. Current status: " + assignment.getStatus());
                return ResponseEntity.badRequest().body(response);
            }

            // Generate OTP for verification (in production, this should be sent to shop owner)
            // For demo purposes, we'll accept "1234" as valid OTP or generate based on order ID
            String validOtp = generatePickupOtp(orderId);

            if (otpCode.equals(validOtp) || otpCode.equals("1234")) {
                // Update assignment status to PICKED_UP
                assignment.setStatus("PICKED_UP");
                assignment.setPickupTime(LocalDateTime.now());
                orderAssignmentService.save(assignment);

                // Update order status
                assignment.getOrder().setStatus("PICKED_UP");

                log.info("Order {} successfully picked up by partner {}", orderId, partnerId);

                response.put("success", true);
                response.put("message", "Order successfully picked up from shop");
                response.put("orderStatus", "PICKED_UP");
                response.put("pickupTime", assignment.getPickupTime().toString());

                // Return customer navigation data
                Map<String, Object> customerInfo = new HashMap<>();
                customerInfo.put("name", assignment.getOrder().getCustomerName());
                customerInfo.put("phone", assignment.getOrder().getCustomerPhone());
                customerInfo.put("address", assignment.getOrder().getDeliveryAddress());

                response.put("customerInfo", customerInfo);
                response.put("navigationReady", true);

            } else {
                response.put("success", false);
                response.put("message", "Invalid OTP. Please check with shop owner.");
                response.put("validOtp", validOtp); // Remove this in production!
            }

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Error verifying pickup OTP: {}", e.getMessage(), e);
            response.put("success", false);
            response.put("message", "Error verifying OTP: " + e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @GetMapping("/dashboard/{partnerId}")
    @Transactional(readOnly = true)
    public ResponseEntity<Map<String, Object>> getDashboard(@PathVariable String partnerId) {
        Map<String, Object> response = new HashMap<>();

        try {
            Long id = Long.parseLong(partnerId);

            // Get partner info
            Optional<User> partnerOpt = userService.findById(id);
            if (partnerOpt.isEmpty()) {
                response.put("success", false);
                response.put("message", "Partner not found");
                return ResponseEntity.badRequest().body(response);
            }

            User partner = partnerOpt.get();

            // Partner Status
            Map<String, Object> partnerStatus = new HashMap<>();
            partnerStatus.put("id", partner.getId());
            partnerStatus.put("name", partner.getName());
            partnerStatus.put("email", partner.getEmail());
            partnerStatus.put("phone", partner.getPhone());
            partnerStatus.put("isOnline", partner.getIsOnline());
            partnerStatus.put("isAvailable", partner.getIsAvailable());
            partnerStatus.put("rideStatus", partner.getRideStatus());
            partnerStatus.put("lastActivity", partner.getLastActivity());

            // Today's Statistics
            LocalDateTime startOfDay = LocalDateTime.now().withHour(0).withMinute(0).withSecond(0);
            List<OrderAssignment> todayAssignments = orderAssignmentService.findByDeliveryPartnerIdAndDateRange(id, startOfDay, LocalDateTime.now());

            Map<String, Object> todayStats = new HashMap<>();
            todayStats.put("totalOrders", todayAssignments.size());
            todayStats.put("completedOrders", todayAssignments.stream().mapToInt(a -> "DELIVERED".equals(a.getStatus()) ? 1 : 0).sum());
            todayStats.put("totalEarnings", todayAssignments.stream()
                .filter(a -> "DELIVERED".equals(a.getStatus()))
                .mapToDouble(a -> a.getOrder().getTotalAmount() != null ? a.getOrder().getTotalAmount().doubleValue() : 0.0)
                .sum());
            todayStats.put("successRate", todayAssignments.isEmpty() ? 0 :
                (todayAssignments.stream().mapToInt(a -> "DELIVERED".equals(a.getStatus()) ? 1 : 0).sum() * 100.0 / todayAssignments.size()));

            // Available Orders
            List<OrderAssignment> availableAssignments = orderAssignmentService.findAvailableOrdersForPartner(id);
            List<Map<String, Object>> availableOrders = availableAssignments.stream()
                .limit(10) // Limit to 10 for dashboard
                .map(this::mapOrderAssignmentToResponse)
                .collect(Collectors.toList());

            // Active Orders
            List<OrderAssignment> activeAssignments = orderAssignmentService.findActiveOrdersForPartner(id);
            List<Map<String, Object>> activeOrders = activeAssignments.stream()
                .map(this::mapOrderAssignmentToResponse)
                .collect(Collectors.toList());

            // Build response
            response.put("success", true);
            response.put("partnerStatus", partnerStatus);
            response.put("todayStats", todayStats);
            response.put("availableOrders", availableOrders);
            response.put("activeOrders", activeOrders);
            response.put("timestamp", LocalDateTime.now().toString());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Error getting dashboard for partner {}: {}", partnerId, e.getMessage(), e);
            response.put("success", false);
            response.put("message", "Error loading dashboard: " + e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @PostMapping("/fcm-token")
    public ResponseEntity<Map<String, Object>> registerFcmToken(@RequestBody Map<String, String> request) {
        Map<String, Object> response = new HashMap<>();

        try {
            String partnerId = request.get("partnerId");
            String fcmToken = request.get("fcmToken");
            String deviceId = request.get("deviceId");

            if (partnerId == null || fcmToken == null) {
                response.put("success", false);
                response.put("message", "Partner ID and FCM token are required");
                return ResponseEntity.badRequest().body(response);
            }

            Long id = Long.parseLong(partnerId);
            Optional<User> partnerOpt = userService.findById(id);

            if (partnerOpt.isEmpty()) {
                response.put("success", false);
                response.put("message", "Partner not found");
                return ResponseEntity.badRequest().body(response);
            }

            User partner = partnerOpt.get();

            // Update FCM token
            partner.setFcmToken(fcmToken);
            partner.setDeviceId(deviceId);
            partner.setLastActivity(LocalDateTime.now());
            userService.save(partner);

            log.info("FCM token registered for partner {} ({})", partner.getName(), partnerId);

            response.put("success", true);
            response.put("message", "FCM token registered successfully");
            response.put("partnerId", partnerId);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Error registering FCM token: {}", e.getMessage(), e);
            response.put("success", false);
            response.put("message", "Error registering FCM token: " + e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @DeleteMapping("/fcm-token")
    public ResponseEntity<Map<String, Object>> unregisterFcmToken(@RequestParam String partnerId, @RequestParam String fcmToken) {
        Map<String, Object> response = new HashMap<>();

        try {
            Long id = Long.parseLong(partnerId);
            Optional<User> partnerOpt = userService.findById(id);

            if (partnerOpt.isEmpty()) {
                response.put("success", false);
                response.put("message", "Partner not found");
                return ResponseEntity.badRequest().body(response);
            }

            User partner = partnerOpt.get();

            // Remove FCM token if it matches
            if (fcmToken.equals(partner.getFcmToken())) {
                partner.setFcmToken(null);
                partner.setDeviceId(null);
                userService.save(partner);

                log.info("FCM token unregistered for partner {} ({})", partner.getName(), partnerId);

                response.put("success", true);
                response.put("message", "FCM token unregistered successfully");
            } else {
                response.put("success", false);
                response.put("message", "FCM token mismatch");
            }

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Error unregistering FCM token: {}", e.getMessage(), e);
            response.put("success", false);
            response.put("message", "Error unregistering FCM token: " + e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    // Location Tracking API Endpoints
    @PostMapping("/update-location")
    @Transactional
    public ResponseEntity<Map<String, Object>> updateLocation(@RequestBody Map<String, Object> request) {
        try {
            Long partnerId = Long.valueOf(request.get("partnerId").toString());
            Double latitude = Double.valueOf(request.get("latitude").toString());
            Double longitude = Double.valueOf(request.get("longitude").toString());

            DeliveryPartnerLocation location = new DeliveryPartnerLocation();
            location.setPartnerId(partnerId);
            location.setLatitude(latitude);
            location.setLongitude(longitude);
            location.setTimestamp(LocalDateTime.now());

            // Add optional fields
            if (request.containsKey("accuracy")) {
                location.setAccuracy(Double.valueOf(request.get("accuracy").toString()));
            }
            if (request.containsKey("speed")) {
                location.setSpeed(Double.valueOf(request.get("speed").toString()));
            }
            if (request.containsKey("heading")) {
                location.setHeading(Double.valueOf(request.get("heading").toString()));
            }
            if (request.containsKey("altitude")) {
                location.setAltitude(Double.valueOf(request.get("altitude").toString()));
            }
            if (request.containsKey("batteryLevel")) {
                location.setBatteryLevel(Integer.valueOf(request.get("batteryLevel").toString()));
            }
            if (request.containsKey("networkType")) {
                location.setNetworkType(request.get("networkType").toString());
            }
            if (request.containsKey("assignmentId")) {
                location.setAssignmentId(Long.valueOf(request.get("assignmentId").toString()));
            }
            if (request.containsKey("orderStatus")) {
                location.setOrderStatus(request.get("orderStatus").toString());
            }

            deliveryPartnerLocationRepository.save(location);

            // Update user's last location and activity
            Optional<User> userOpt = userService.findById(partnerId);
            if (userOpt.isPresent()) {
                User user = userOpt.get();
                user.setCurrentLatitude(latitude);
                user.setCurrentLongitude(longitude);
                user.setLastLocationUpdate(LocalDateTime.now());
                user.setLastActivity(LocalDateTime.now());
                userService.save(user);
            }

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("message", "Location updated successfully");
            response.put("timestamp", LocalDateTime.now());

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error updating delivery partner location: {}", e.getMessage());

            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", e.getMessage());

            return ResponseEntity.badRequest().body(response);
        }
    }

    @GetMapping("/location-history/{partnerId}")
    @Transactional(readOnly = true)
    public ResponseEntity<Map<String, Object>> getLocationHistory(
            @PathVariable Long partnerId,
            @RequestParam(required = false) Long assignmentId,
            @RequestParam(defaultValue = "24") int hours) {
        try {
            LocalDateTime startTime = LocalDateTime.now().minusHours(hours);

            List<DeliveryPartnerLocation> locations;
            if (assignmentId != null) {
                locations = deliveryPartnerLocationRepository
                    .findByPartnerIdAndAssignmentIdAndTimestampAfterOrderByTimestampDesc(
                        partnerId, assignmentId, startTime);
            } else {
                locations = deliveryPartnerLocationRepository
                    .findByPartnerIdAndTimestampAfterOrderByTimestampDesc(partnerId, startTime);
            }

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("locations", locations);
            response.put("count", locations.size());

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error fetching location history for partner {}: {}", partnerId, e.getMessage());

            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", e.getMessage());

            return ResponseEntity.badRequest().body(response);
        }
    }

    @PostMapping("/journey/start-to-shop")
    @Transactional
    public ResponseEntity<Map<String, Object>> startJourneyToShop(@RequestBody Map<String, Object> request) {
        try {
            Long partnerId = Long.valueOf(request.get("partnerId").toString());
            Long assignmentId = Long.valueOf(request.get("assignmentId").toString());
            Double shopLat = Double.valueOf(request.get("shopLat").toString());
            Double shopLng = Double.valueOf(request.get("shopLng").toString());

            // Update assignment status
            Optional<OrderAssignment> assignmentOpt = orderAssignmentService.findById(assignmentId);
            if (assignmentOpt.isEmpty()) {
                throw new RuntimeException("Assignment not found: " + assignmentId);
            }

            OrderAssignment assignment = assignmentOpt.get();
            assignment.setStatus(OrderAssignment.AssignmentStatus.IN_PROGRESS);
            assignment.setPickupStartedAt(LocalDateTime.now());
            orderAssignmentService.save(assignment);

            // Calculate distance and ETA
            Optional<User> userOpt = userService.findById(partnerId);
            double distance = 0;
            String eta = "N/A";

            if (userOpt.isPresent() && userOpt.get().getCurrentLatitude() != null) {
                User user = userOpt.get();
                distance = calculateDistance(
                    user.getCurrentLatitude(), user.getCurrentLongitude(),
                    shopLat, shopLng
                );
                eta = calculateETA(distance, 25.0); // Assume 25 km/h average speed
            }

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("message", "Journey to shop started");
            response.put("distanceToShop", Math.round(distance * 100.0) / 100.0);
            response.put("estimatedTime", eta);
            response.put("shopLocation", Map.of("lat", shopLat, "lng", shopLng));

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error starting journey to shop: {}", e.getMessage());

            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", e.getMessage());

            return ResponseEntity.badRequest().body(response);
        }
    }

    @PostMapping("/journey/start-to-customer")
    @Transactional
    public ResponseEntity<Map<String, Object>> startJourneyToCustomer(@RequestBody Map<String, Object> request) {
        try {
            Long partnerId = Long.valueOf(request.get("partnerId").toString());
            Long assignmentId = Long.valueOf(request.get("assignmentId").toString());
            Double customerLat = Double.valueOf(request.get("customerLat").toString());
            Double customerLng = Double.valueOf(request.get("customerLng").toString());

            // Update assignment status
            Optional<OrderAssignment> assignmentOpt = orderAssignmentService.findById(assignmentId);
            if (assignmentOpt.isEmpty()) {
                throw new RuntimeException("Assignment not found: " + assignmentId);
            }

            OrderAssignment assignment = assignmentOpt.get();
            assignment.setStatus(OrderAssignment.AssignmentStatus.PICKED_UP);
            assignment.setPickupCompletedAt(LocalDateTime.now());
            assignment.setDeliveryStartedAt(LocalDateTime.now());
            orderAssignmentService.save(assignment);

            // Calculate distance and ETA
            Optional<User> userOpt = userService.findById(partnerId);
            double distance = 0;
            String eta = "N/A";

            if (userOpt.isPresent() && userOpt.get().getCurrentLatitude() != null) {
                User user = userOpt.get();
                distance = calculateDistance(
                    user.getCurrentLatitude(), user.getCurrentLongitude(),
                    customerLat, customerLng
                );
                eta = calculateETA(distance, 25.0); // Assume 25 km/h average speed
            }

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("message", "Journey to customer started");
            response.put("distanceToCustomer", Math.round(distance * 100.0) / 100.0);
            response.put("estimatedTime", eta);
            response.put("customerLocation", Map.of("lat", customerLat, "lng", customerLng));

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error starting journey to customer: {}", e.getMessage());

            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", e.getMessage());

            return ResponseEntity.badRequest().body(response);
        }
    }

    @PostMapping("/journey/arrived-at-shop")
    @Transactional
    public ResponseEntity<Map<String, Object>> arrivedAtShop(@RequestBody Map<String, Object> request) {
        try {
            Long partnerId = Long.valueOf(request.get("partnerId").toString());
            Long assignmentId = Long.valueOf(request.get("assignmentId").toString());

            // Update assignment status
            Optional<OrderAssignment> assignmentOpt = orderAssignmentService.findById(assignmentId);
            if (assignmentOpt.isEmpty()) {
                throw new RuntimeException("Assignment not found: " + assignmentId);
            }

            OrderAssignment assignment = assignmentOpt.get();
            assignment.setArrivedAtShopAt(LocalDateTime.now());
            orderAssignmentService.save(assignment);

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("message", "Arrival at shop confirmed");
            response.put("arrivedAt", LocalDateTime.now());

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error confirming arrival at shop: {}", e.getMessage());

            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", e.getMessage());

            return ResponseEntity.badRequest().body(response);
        }
    }

    @PostMapping("/journey/arrived-at-customer")
    @Transactional
    public ResponseEntity<Map<String, Object>> arrivedAtCustomer(@RequestBody Map<String, Object> request) {
        try {
            Long partnerId = Long.valueOf(request.get("partnerId").toString());
            Long assignmentId = Long.valueOf(request.get("assignmentId").toString());

            // Update assignment status
            Optional<OrderAssignment> assignmentOpt = orderAssignmentService.findById(assignmentId);
            if (assignmentOpt.isEmpty()) {
                throw new RuntimeException("Assignment not found: " + assignmentId);
            }

            OrderAssignment assignment = assignmentOpt.get();
            assignment.setArrivedAtCustomerAt(LocalDateTime.now());
            orderAssignmentService.save(assignment);

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("message", "Arrival at customer location confirmed");
            response.put("arrivedAt", LocalDateTime.now());

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error confirming arrival at customer: {}", e.getMessage());

            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", e.getMessage());

            return ResponseEntity.badRequest().body(response);
        }
    }

    // Helper methods for distance and ETA calculations
    private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
        if (lat1 == lat2 && lon1 == lon2) return 0;

        double R = 6371; // Earth's radius in kilometers
        double dLat = Math.toRadians(lat2 - lat1);
        double dLon = Math.toRadians(lon2 - lon1);
        double a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    private String calculateETA(double distanceKm, double speedKmh) {
        if (distanceKm <= 0 || speedKmh <= 0) return "N/A";

        double etaHours = distanceKm / speedKmh;
        int etaMinutes = (int) Math.round(etaHours * 60);

        if (etaMinutes < 1) {
            return "< 1 min";
        } else if (etaMinutes < 60) {
            return etaMinutes + " min";
        } else {
            int hours = etaMinutes / 60;
            int minutes = etaMinutes % 60;
            return hours + "h " + minutes + "m";
        }
    }

    // Emergency/SOS API Endpoints
    @PostMapping("/emergency/sos")
    @Transactional
    public ResponseEntity<Map<String, Object>> triggerEmergencySOS(@RequestBody Map<String, Object> request) {
        try {
            Long partnerId = Long.valueOf(request.get("partnerId").toString());
            String emergencyType = request.get("emergencyType").toString(); // "ACCIDENT", "ROBBERY", "MEDICAL", "OTHER"
            String description = request.get("description") != null ? request.get("description").toString() : "";

            // Get current location
            Double latitude = null;
            Double longitude = null;
            if (request.containsKey("latitude") && request.containsKey("longitude")) {
                latitude = Double.valueOf(request.get("latitude").toString());
                longitude = Double.valueOf(request.get("longitude").toString());
            }

            // Get partner details
            Optional<User> userOpt = userService.findById(partnerId);
            if (userOpt.isEmpty()) {
                throw new RuntimeException("Delivery partner not found: " + partnerId);
            }

            User partner = userOpt.get();

            // Get location address if provided
            String locationAddress = null;
            if (request.containsKey("locationAddress")) {
                locationAddress = request.get("locationAddress").toString();
            }

            // Create emergency using the EmergencyService (real database)
            Emergency emergency = emergencyService.createEmergency(
                partner, emergencyType, description, latitude, longitude, locationAddress
            );

            // Create emergency record with complete driver profile for admin
            Map<String, Object> emergencyData = new HashMap<>();
            emergencyData.put("partnerId", partnerId);
            emergencyData.put("partnerName", partner.getFirstName() + " " + partner.getLastName());
            emergencyData.put("partnerPhone", partner.getMobileNumber());
            emergencyData.put("partnerEmail", partner.getEmail());
            emergencyData.put("emergencyType", emergencyType);
            emergencyData.put("description", description);
            emergencyData.put("timestamp", LocalDateTime.now());
            emergencyData.put("latitude", latitude);
            emergencyData.put("longitude", longitude);
            emergencyData.put("status", "ACTIVE");

            // Add additional emergency context for admin
            String emergencyId = "EMG" + partnerId + "_" + System.currentTimeMillis();
            emergencyData.put("emergencyId", emergencyId);
            emergencyData.put("severity", getSeverityLevel(emergencyType));
            emergencyData.put("requiresPolice", requiresPoliceResponse(emergencyType));
            emergencyData.put("requiresAmbulance", requiresMedicalResponse(emergencyType));
            emergencyData.put("estimatedResponseTime", getEstimatedResponseTime(emergencyType));
            emergencyData.put("locationAddress", "Location coordinates provided"); // You can add geocoding here
            emergencyData.put("nearbyLandmarks", "Checking nearby landmarks..."); // Add landmark detection

            // Add complete driver profile for admin app
            Map<String, Object> driverProfile = new HashMap<>();
            driverProfile.put("id", partner.getId());
            driverProfile.put("username", partner.getUsername());
            driverProfile.put("firstName", partner.getFirstName());
            driverProfile.put("lastName", partner.getLastName());
            driverProfile.put("fullName", (partner.getFirstName() + " " + partner.getLastName()).trim());
            driverProfile.put("email", partner.getEmail());
            driverProfile.put("mobileNumber", partner.getMobileNumber());
            driverProfile.put("profileImageUrl", partner.getProfileImageUrl());
            driverProfile.put("department", partner.getDepartment());
            driverProfile.put("designation", partner.getDesignation());
            driverProfile.put("isOnline", partner.getIsOnline());
            driverProfile.put("isAvailable", partner.getIsAvailable());
            driverProfile.put("rideStatus", partner.getRideStatus().name());
            driverProfile.put("lastActivity", partner.getLastActivity());
            driverProfile.put("lastLogin", partner.getLastLogin());
            driverProfile.put("currentLatitude", partner.getCurrentLatitude());
            driverProfile.put("currentLongitude", partner.getCurrentLongitude());
            driverProfile.put("lastLocationUpdate", partner.getLastLocationUpdate());
            driverProfile.put("createdAt", partner.getCreatedAt());
            driverProfile.put("fcmToken", partner.getFcmToken());
            driverProfile.put("deviceId", partner.getDeviceId());

            // Add user role information
            driverProfile.put("role", partner.getUserRole().name());
            driverProfile.put("isAccountActive", partner.isAccountNonLocked());
            driverProfile.put("isAccountExpired", !partner.isAccountNonExpired());

            emergencyData.put("driverProfile", driverProfile);

            // Log emergency for immediate attention
            log.error(" EMERGENCY SOS TRIGGERED - Partner: {} ({}), Type: {}, Location: {},{}",
                partner.getFirstName() + " " + partner.getLastName(),
                partner.getMobileNumber(),
                emergencyType,
                latitude,
                longitude
            );

            // Send immediate notifications to admin systems
            try {
                // 1. Send WebSocket notification to Angular admin app with ALARM
                sendEmergencyNotificationToAdmin(emergencyData);

                // 2. Send FCM push notification to admin app
                sendFCMNotificationToAdmin(emergencyData);

                // 3. Log in database for tracking (implement Emergency entity later)
                log.error(" EMERGENCY ALERT LOGGED - ID: EMG{}", System.currentTimeMillis());

                // 4. You can add SMS/Email alerts here
                // sendSMSToEmergencyContacts(emergencyData);
                // sendEmailToManagement(emergencyData);

            } catch (Exception e) {
                log.error("Error sending emergency notifications: {}", e.getMessage());
                // Don't fail the SOS if notifications fail - driver safety is priority
            }

            // For now, we'll update partner status to indicate emergency
            partner.setRideStatus(RideStatus.OFFLINE);
            partner.setLastActivity(LocalDateTime.now());
            userService.save(partner);

            // Send immediate response with actual emergency data
            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("message", "Emergency SOS activated. Help is on the way!");
            response.put("emergencyId", emergency.getEmergencyId());
            response.put("timestamp", emergency.getCreatedAt());
            response.put("emergencyContacts", getEmergencyContactsList());

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error processing emergency SOS: {}", e.getMessage());

            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", "Failed to process emergency alert: " + e.getMessage());

            return ResponseEntity.badRequest().body(response);
        }
    }

    @PostMapping("/emergency/cancel")
    @Transactional
    public ResponseEntity<Map<String, Object>> cancelEmergencySOS(@RequestBody Map<String, Object> request) {
        try {
            Long partnerId = Long.valueOf(request.get("partnerId").toString());
            String emergencyId = request.get("emergencyId").toString();

            Optional<User> userOpt = userService.findById(partnerId);
            if (userOpt.isEmpty()) {
                throw new RuntimeException("Delivery partner not found: " + partnerId);
            }

            User partner = userOpt.get();

            // Cancel the emergency using EmergencyService (real database)
            Emergency cancelledEmergency = emergencyService.cancelEmergency(emergencyId, partnerId);

            log.info("Emergency SOS cancelled by partner: {} ({})",
                partner.getFirstName() + " " + partner.getLastName(),
                partner.getMobileNumber()
            );

            // Update partner status back to available
            partner.setRideStatus(RideStatus.AVAILABLE);
            partner.setLastActivity(LocalDateTime.now());
            userService.save(partner);

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("message", "Emergency SOS cancelled successfully");
            response.put("emergencyId", cancelledEmergency.getEmergencyId());
            response.put("status", cancelledEmergency.getStatus().name());

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error cancelling emergency SOS: {}", e.getMessage());

            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", e.getMessage());

            return ResponseEntity.badRequest().body(response);
        }
    }

    @GetMapping("/emergency/contacts")
    public ResponseEntity<Map<String, Object>> getEmergencyContacts() {
        Map<String, Object> response = new HashMap<>();
        response.put("success", true);
        response.put("contacts", getEmergencyContactsList());
        return ResponseEntity.ok(response);
    }

    @GetMapping("/emergency/history/{partnerId}")
    @Transactional(readOnly = true)
    public ResponseEntity<Map<String, Object>> getEmergencyHistory(@PathVariable Long partnerId) {
        try {
            log.info(" Fetching emergency history for partner: {}", partnerId);

            // Get partner details
            Optional<User> userOpt = userService.findById(partnerId);
            if (userOpt.isEmpty()) {
                Map<String, Object> response = new HashMap<>();
                response.put("success", false);
                response.put("message", "Delivery partner not found");
                return ResponseEntity.badRequest().body(response);
            }

            User partner = userOpt.get();
            List<Map<String, Object>> emergencyHistory = new ArrayList<>();

            // Get real emergency history from database
            List<Emergency> emergencies = emergencyService.getPartnerEmergencyHistory(partnerId);

            // Convert emergencies to response format
            for (Emergency emergency : emergencies) {
                emergencyHistory.add(emergencyService.convertToMap(emergency));
            }

            // Get statistics
            Map<String, Object> stats = emergencyService.getEmergencyStatistics(partnerId);

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("emergencyHistory", emergencyHistory);
            response.put("totalCount", stats.get("totalCount"));
            response.put("activeCount", stats.get("activeCount"));
            response.put("resolvedCount", stats.get("resolvedCount"));
            response.put("cancelledCount", stats.get("cancelledCount"));

            log.info(" Emergency history fetched successfully for partner: {} - {} records", partnerId, emergencyHistory.size());
            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error(" Error fetching emergency history for partner: {}", partnerId, e);
            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", "Failed to fetch emergency history: " + e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @PostMapping("/emergency/update-status")
    @Transactional
    public ResponseEntity<Map<String, Object>> updateEmergencyStatus(@RequestBody Map<String, Object> request) {
        try {
            String emergencyId = request.get("emergencyId").toString();
            String newStatus = request.get("newStatus").toString(); // "RESOLVED", "IN_PROGRESS", "CANCELLED"
            String adminNotes = request.get("adminNotes") != null ? request.get("adminNotes").toString() : "";
            String resolvedBy = request.get("resolvedBy") != null ? request.get("resolvedBy").toString() : "ADMIN";

            // Update emergency using EmergencyService
            Emergency updatedEmergency = emergencyService.updateEmergencyStatus(
                emergencyId, newStatus, adminNotes, resolvedBy
            );

            Long partnerId = updatedEmergency.getPartner().getId();

            // Get partner details
            Optional<User> userOpt = userService.findById(partnerId);
            if (userOpt.isEmpty()) {
                throw new RuntimeException("Delivery partner not found: " + partnerId);
            }

            User partner = userOpt.get();

            // Update partner status based on emergency resolution
            if ("RESOLVED".equals(newStatus)) {
                partner.setRideStatus(RideStatus.AVAILABLE);
                partner.setIsAvailable(true);
                partner.setLastActivity(LocalDateTime.now());

                log.info("Emergency {} RESOLVED for partner: {} by {}",
                    emergencyId,
                    partner.getFirstName() + " " + partner.getLastName(),
                    resolvedBy
                );
            } else if ("IN_PROGRESS".equals(newStatus)) {
                partner.setRideStatus(RideStatus.BUSY);
                partner.setIsAvailable(false);

                log.info("Emergency {} IN_PROGRESS for partner: {}",
                    emergencyId,
                    partner.getFirstName() + " " + partner.getLastName()
                );
            }

            userService.save(partner);

            // Create status update notification for tracking
            Map<String, Object> statusUpdate = new HashMap<>();
            statusUpdate.put("emergencyId", emergencyId);
            statusUpdate.put("partnerId", partnerId);
            statusUpdate.put("partnerName", partner.getFirstName() + " " + partner.getLastName());
            statusUpdate.put("oldStatus", "ACTIVE");
            statusUpdate.put("newStatus", newStatus);
            statusUpdate.put("resolvedBy", resolvedBy);
            statusUpdate.put("resolutionNotes", resolutionNotes);
            statusUpdate.put("resolvedAt", LocalDateTime.now());

            // Notify admin systems about status change
            sendEmergencyStatusUpdateToAdmin(statusUpdate);

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("message", "Emergency status updated to " + newStatus);
            response.put("statusUpdate", statusUpdate);

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error updating emergency status: {}", e.getMessage());

            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", "Failed to update emergency status: " + e.getMessage());

            return ResponseEntity.badRequest().body(response);
        }
    }

    @GetMapping("/emergency/all-active")
    @Transactional(readOnly = true)
    public ResponseEntity<Map<String, Object>> getAllActiveEmergencies() {
        try {
            // Get all active emergencies from database
            List<Map<String, Object>> activeEmergencies = new ArrayList<>();

            // Query active emergencies that need response
            List<Emergency> emergencies = emergencyService.getEmergenciesNeedingResponse();

            // Convert to response format with full driver profiles
            for (Emergency emergency : emergencies) {
                Map<String, Object> emergencyData = emergencyService.convertToMap(emergency);

                // Add complete driver profile data
                User partner = emergency.getPartner();
                Map<String, Object> driverProfile = new HashMap<>();
                driverProfile.put("id", partner.getId());
                driverProfile.put("username", partner.getUsername());
                driverProfile.put("firstName", partner.getFirstName());
                driverProfile.put("lastName", partner.getLastName());
                driverProfile.put("fullName", (partner.getFirstName() + " " + partner.getLastName()).trim());
                driverProfile.put("email", partner.getEmail());
                driverProfile.put("mobileNumber", partner.getMobileNumber());
                driverProfile.put("profileImageUrl", partner.getProfileImageUrl());
                driverProfile.put("department", partner.getDepartment());
                driverProfile.put("designation", partner.getDesignation());
                driverProfile.put("isOnline", partner.getIsOnline());
                driverProfile.put("isAvailable", partner.getIsAvailable());
                driverProfile.put("rideStatus", partner.getRideStatus().name());
                driverProfile.put("lastActivity", partner.getLastActivity());
                driverProfile.put("lastLogin", partner.getLastLogin());
                driverProfile.put("currentLatitude", partner.getCurrentLatitude());
                driverProfile.put("currentLongitude", partner.getCurrentLongitude());
                driverProfile.put("lastLocationUpdate", partner.getLastLocationUpdate());
                driverProfile.put("createdAt", partner.getCreatedAt());
                driverProfile.put("fcmToken", partner.getFcmToken());
                driverProfile.put("deviceId", partner.getDeviceId());
                driverProfile.put("role", partner.getUserRole().name());
                driverProfile.put("isAccountActive", partner.isAccountNonLocked());
                driverProfile.put("isAccountExpired", !partner.isAccountNonExpired());

                emergencyData.put("driverProfile", driverProfile);
                activeEmergencies.add(emergencyData);
            }

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("emergencies", activeEmergencies);
            response.put("count", activeEmergencies.size());

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error fetching active emergencies: {}", e.getMessage());

            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("message", e.getMessage());

            return ResponseEntity.badRequest().body(response);
        }
    }

    // Helper method to get emergency contacts
    private List<Map<String, Object>> getEmergencyContactsList() {
        List<Map<String, Object>> contacts = new ArrayList<>();

        // Police
        Map<String, Object> police = new HashMap<>();
        police.put("name", "Police");
        police.put("number", "100");
        police.put("type", "POLICE");
        contacts.add(police);

        // Ambulance
        Map<String, Object> ambulance = new HashMap<>();
        ambulance.put("name", "Ambulance");
        ambulance.put("number", "108");
        ambulance.put("type", "MEDICAL");
        contacts.add(ambulance);

        // Company Emergency
        Map<String, Object> company = new HashMap<>();
        company.put("name", "NammaOoru Support");
        company.put("number", "+91 98765 43210");
        company.put("type", "COMPANY");
        contacts.add(company);

        return contacts;
    }

    // Emergency notification helpers
    private void sendEmergencyNotificationToAdmin(Map<String, Object> emergencyData) {
        try {
            // Create emergency notification payload for Angular admin app
            Map<String, Object> notification = new HashMap<>();
            notification.put("type", "EMERGENCY_SOS");
            notification.put("priority", "CRITICAL");
            notification.put("sound", "ALARM"); // Trigger alarm sound in admin app
            notification.put("data", emergencyData);
            notification.put("timestamp", LocalDateTime.now());

            // Send WebSocket notification to admin app
            // webSocketService.sendToAdminApp("emergency-alert", notification);

            log.error(" EMERGENCY WEBSOCKET SENT TO ADMIN: {}", notification);

            // For now, we'll log it. In production, implement WebSocket service

        } catch (Exception e) {
            log.error("Failed to send WebSocket emergency notification: {}", e.getMessage());
        }
    }

    private void sendFCMNotificationToAdmin(Map<String, Object> emergencyData) {
        try {
            // Create FCM payload for admin mobile/web app
            Map<String, Object> fcmPayload = new HashMap<>();
            fcmPayload.put("title", " EMERGENCY SOS ACTIVATED");
            fcmPayload.put("body", String.format("Driver %s needs immediate help! Emergency: %s",
                emergencyData.get("partnerName"),
                emergencyData.get("emergencyType")));
            fcmPayload.put("type", "EMERGENCY_ALERT");
            fcmPayload.put("sound", "emergency_alarm"); // Custom alarm sound
            fcmPayload.put("priority", "high");
            fcmPayload.put("data", emergencyData);

            // Send to admin FCM tokens
            firebaseNotificationService.sendEmergencyNotificationToAdmins(emergencyData);

            log.error(" EMERGENCY FCM SENT TO ADMIN: {}", fcmPayload);

        } catch (Exception e) {
            log.error("Failed to send FCM emergency notification: {}", e.getMessage());
        }
    }

    private void sendEmergencyStatusUpdateToAdmin(Map<String, Object> statusUpdate) {
        try {
            // Create status update notification for Angular admin app
            Map<String, Object> notification = new HashMap<>();
            notification.put("type", "EMERGENCY_STATUS_UPDATE");
            notification.put("priority", "HIGH");
            notification.put("data", statusUpdate);
            notification.put("timestamp", LocalDateTime.now());

            // Send WebSocket notification to admin app
            // webSocketService.sendToAdminApp("emergency-status-update", notification);

            log.info(" EMERGENCY STATUS UPDATE SENT TO ADMIN: {}", notification);

        } catch (Exception e) {
            log.error("Failed to send emergency status update: {}", e.getMessage());
        }
    }

    // Emergency severity and response helper methods
    private String getSeverityLevel(String emergencyType) {
        return switch (emergencyType.toUpperCase()) {
            case "ACCIDENT" -> "HIGH";
            case "ROBBERY" -> "HIGH";
            case "MEDICAL" -> "CRITICAL";
            case "VEHICLE_BREAKDOWN" -> "MEDIUM";
            case "OTHER" -> "MEDIUM";
            default -> "MEDIUM";
        };
    }

    private boolean requiresPoliceResponse(String emergencyType) {
        return emergencyType.toUpperCase().equals("ROBBERY") ||
               emergencyType.toUpperCase().equals("ACCIDENT");
    }

    private boolean requiresMedicalResponse(String emergencyType) {
        return emergencyType.toUpperCase().equals("MEDICAL") ||
               emergencyType.toUpperCase().equals("ACCIDENT");
    }

    private String getEstimatedResponseTime(String emergencyType) {
        return switch (emergencyType.toUpperCase()) {
            case "MEDICAL" -> "5-10 minutes";
            case "ACCIDENT" -> "10-15 minutes";
            case "ROBBERY" -> "5-8 minutes";
            case "VEHICLE_BREAKDOWN" -> "20-30 minutes";
            case "OTHER" -> "15-20 minutes";
            default -> "10-15 minutes";
        };
    }

    // Helper method to generate pickup OTP (in production, send to shop owner)
    private String generatePickupOtp(Long orderId) {
        // Simple OTP generation based on order ID (in production, use proper random OTP)
        int otpNum = (int) (orderId % 9000) + 1000; // 4-digit number
        return String.valueOf(otpNum);
    }
}