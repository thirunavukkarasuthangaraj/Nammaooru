package com.shopmanagement.service;

import com.shopmanagement.dto.auth.AuthResponse;
import com.shopmanagement.entity.User;
import com.shopmanagement.entity.Customer;
import com.shopmanagement.repository.UserRepository;
import com.shopmanagement.repository.CustomerRepository;
// import com.shopmanagement.security.JwtUtil;
import com.shopmanagement.util.PhoneNumberUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ThreadLocalRandom;

@Service
@RequiredArgsConstructor
@Slf4j
public class WhatsAppAuthService {

    private final UserRepository userRepository;
    private final CustomerRepository customerRepository;
    // private final JwtUtil jwtUtil;
    private final PasswordEncoder passwordEncoder;

    @Value("${app.otp.expiry-minutes:5}")
    private int otpExpiryMinutes;

    @Value("${app.otp.max-attempts:3}")
    private int maxOtpAttempts;

    @Value("${app.development.mode:false}")
    private boolean developmentMode;

    // In-memory OTP storage (in production, use Redis or database)
    private final Map<String, OTPSession> otpSessions = new ConcurrentHashMap<>();

    /**
     * Send OTP via WhatsApp or SMS
     */
    public Map<String, Object> sendOTP(String mobileNumber, String channel, String name, String purpose) {
        try {
            // Normalize mobile number
            String normalizedNumber = PhoneNumberUtil.normalize(mobileNumber);

            // Generate OTP
            String otp = generateOTP();

            // Create or update OTP session
            OTPSession session = new OTPSession();
            session.setOtp(otp);
            session.setMobileNumber(normalizedNumber);
            session.setChannel(channel);
            session.setPurpose(purpose);
            session.setCreatedAt(LocalDateTime.now());
            session.setExpiresAt(LocalDateTime.now().plus(otpExpiryMinutes, ChronoUnit.MINUTES));
            session.setAttempts(0);
            session.setVerified(false);

            otpSessions.put(normalizedNumber, session);

            // In production, integrate with actual WhatsApp/SMS gateway
            if ("whatsapp".equals(channel)) {
                sendWhatsAppOTP(normalizedNumber, otp, name);
            } else {
                sendSMSOTP(normalizedNumber, otp, name);
            }

            log.info("OTP sent to {} via {}", normalizedNumber, channel);

            Map<String, Object> response = new HashMap<>();
            response.put("sessionId", UUID.randomUUID().toString());
            response.put("expiresAt", session.getExpiresAt());
            response.put("channel", channel);

            // Include test OTP in development mode
            if (developmentMode) {
                response.put("testOTP", otp);
                log.warn("Development mode: OTP {} sent to {}", otp, normalizedNumber);
            }

            return response;

        } catch (Exception e) {
            log.error("Error sending OTP to {}: ", mobileNumber, e);
            throw new RuntimeException("Failed to send OTP");
        }
    }

    /**
     * Verify OTP and authenticate user
     */
    @Transactional
    public AuthResponse verifyOTP(String mobileNumber, String otp, String deviceToken, String deviceType) {
        try {
            String normalizedNumber = PhoneNumberUtil.normalize(mobileNumber);

            OTPSession session = otpSessions.get(normalizedNumber);
            if (session == null) {
                throw new RuntimeException("No OTP session found. Please request OTP again.");
            }

            // Check if OTP is expired
            if (LocalDateTime.now().isAfter(session.getExpiresAt())) {
                otpSessions.remove(normalizedNumber);
                throw new RuntimeException("OTP has expired. Please request a new one.");
            }

            // Check attempts
            session.setAttempts(session.getAttempts() + 1);
            if (session.getAttempts() > maxOtpAttempts) {
                otpSessions.remove(normalizedNumber);
                throw new RuntimeException("Maximum OTP attempts exceeded. Please request a new OTP.");
            }

            // Verify OTP
            if (!session.getOtp().equals(otp)) {
                int attemptsLeft = maxOtpAttempts - session.getAttempts();
                throw new RuntimeException("Invalid OTP. " + attemptsLeft + " attempts remaining.");
            }

            // Mark as verified
            session.setVerified(true);

            // Find or create user
            User user = userRepository.findByMobileNumber(normalizedNumber).orElse(null);
            boolean isNewUser = false;

            if (user == null) {
                // Create new user
                user = createNewUser(normalizedNumber, deviceToken, deviceType);
                isNewUser = true;
                log.info("Created new user for mobile number: {}", normalizedNumber);
            } else {
                // Update existing user
                user.setLastLoginAt(LocalDateTime.now());
                if (deviceToken != null && !deviceToken.isEmpty()) {
                    user.setDeviceToken(deviceToken);
                }
                user = userRepository.save(user);
                log.info("Updated existing user for mobile number: {}", normalizedNumber);
            }

            // Generate JWT token
            String token = "dummy-token"; // jwtUtil.generateToken(user.getEmail(), user.getId(), user.getRole().name());

            // Clean up OTP session
            otpSessions.remove(normalizedNumber);

            // Create response
            AuthResponse response = new AuthResponse();
            response.setToken(token);
            response.setUserId(user.getId());
            response.setUserType(user.getRole().name());
            response.setNewUser(isNewUser);
            response.setMobileNumber(normalizedNumber);
            response.setEmail(user.getEmail());
            response.setFirstName(user.getFirstName());
            response.setLastName(user.getLastName());

            return response;

        } catch (RuntimeException e) {
            throw e;
        } catch (Exception e) {
            log.error("Error verifying OTP for {}: ", mobileNumber, e);
            throw new RuntimeException("Failed to verify OTP");
        }
    }

    /**
     * Resend OTP
     */
    public Map<String, Object> resendOTP(String mobileNumber, String channel) {
        String normalizedNumber = PhoneNumberUtil.normalize(mobileNumber);

        OTPSession session = otpSessions.get(normalizedNumber);
        if (session == null) {
            throw new RuntimeException("No active OTP session found");
        }

        // Check if enough time has passed since last OTP
        if (session.getCreatedAt().isAfter(LocalDateTime.now().minus(1, ChronoUnit.MINUTES))) {
            throw new RuntimeException("Please wait before requesting another OTP");
        }

        return sendOTP(mobileNumber, channel, null, session.getPurpose());
    }

    /**
     * Get OTP status
     */
    public Map<String, Object> getOTPStatus(String mobileNumber) {
        String normalizedNumber = PhoneNumberUtil.normalize(mobileNumber);

        OTPSession session = otpSessions.get(normalizedNumber);
        Map<String, Object> response = new HashMap<>();

        if (session == null) {
            response.put("exists", false);
            response.put("message", "No OTP session found");
        } else {
            response.put("exists", true);
            response.put("isExpired", LocalDateTime.now().isAfter(session.getExpiresAt()));
            response.put("attempts", session.getAttempts());
            response.put("maxAttempts", maxOtpAttempts);
            response.put("expiresAt", session.getExpiresAt());
            response.put("channel", session.getChannel());
            response.put("verified", session.isVerified());
        }

        return response;
    }

    /**
     * Create new user from mobile number
     */
    private User createNewUser(String mobileNumber, String deviceToken, String deviceType) {
        User user = new User();
        user.setMobileNumber(mobileNumber);
        user.setEmail(mobileNumber + "@whatsapp.nammaooru.com"); // Temporary email
        user.setPassword(passwordEncoder.encode(UUID.randomUUID().toString())); // Random password
        user.setFirstName("User");
        user.setLastName(mobileNumber);
        user.setRole(User.UserRole.USER);
        user.setActive(true);
        user.setCreatedAt(LocalDateTime.now());
        user.setLastLoginAt(LocalDateTime.now());
        user.setDeviceToken(deviceToken);
        user.setEmailVerified(false); // Will be verified later if they provide email

        user = userRepository.save(user);

        // Create customer profile
        Customer customer = new Customer();
        // customer.setUser(user);
        customer.setName(user.getFirstName() + " " + user.getLastName());
        customer.setMobileNumber(mobileNumber);
        customer.setFirstName(user.getFirstName());
        customer.setLastName(user.getLastName());
        customer.setEmail(user.getEmail());

        customerRepository.save(customer);

        return user;
    }

    /**
     * Generate random 6-digit OTP
     */
    private String generateOTP() {
        if (developmentMode) {
            return "123456"; // Fixed OTP for development
        }
        return String.format("%06d", ThreadLocalRandom.current().nextInt(100000, 999999));
    }

    /**
     * Send WhatsApp OTP (placeholder - integrate with actual WhatsApp Business API)
     */
    private void sendWhatsAppOTP(String mobileNumber, String otp, String name) {
        log.info("Sending WhatsApp OTP {} to {}", otp, mobileNumber);

        // TODO: Integrate with WhatsApp Business API
        // Example: WhatsApp Business API call
        /*
        String message = String.format(
            "Hi %s! Your NammaOoru verification code is: *%s*\n\nThis code will expire in %d minutes.\n\nDo not share this code with anyone.",
            name != null ? name : "there",
            otp,
            otpExpiryMinutes
        );

        // WhatsApp Business API integration would go here
        whatsAppBusinessService.sendMessage(mobileNumber, message);
        */
    }

    /**
     * Send SMS OTP (placeholder - integrate with SMS gateway)
     */
    private void sendSMSOTP(String mobileNumber, String otp, String name) {
        log.info("Sending SMS OTP {} to {}", otp, mobileNumber);

        // TODO: Integrate with SMS gateway (Twilio, AWS SNS, etc.)
        /*
        String message = String.format(
            "Your NammaOoru verification code is: %s. Valid for %d minutes. Do not share.",
            otp,
            otpExpiryMinutes
        );

        smsService.sendSMS(mobileNumber, message);
        */
    }

    /**
     * OTP Session data class
     */
    private static class OTPSession {
        private String otp;
        private String mobileNumber;
        private String channel;
        private String purpose;
        private LocalDateTime createdAt;
        private LocalDateTime expiresAt;
        private int attempts;
        private boolean verified;

        // Getters and setters
        public String getOtp() { return otp; }
        public void setOtp(String otp) { this.otp = otp; }

        public String getMobileNumber() { return mobileNumber; }
        public void setMobileNumber(String mobileNumber) { this.mobileNumber = mobileNumber; }

        public String getChannel() { return channel; }
        public void setChannel(String channel) { this.channel = channel; }

        public String getPurpose() { return purpose; }
        public void setPurpose(String purpose) { this.purpose = purpose; }

        public LocalDateTime getCreatedAt() { return createdAt; }
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

        public LocalDateTime getExpiresAt() { return expiresAt; }
        public void setExpiresAt(LocalDateTime expiresAt) { this.expiresAt = expiresAt; }

        public int getAttempts() { return attempts; }
        public void setAttempts(int attempts) { this.attempts = attempts; }

        public boolean isVerified() { return verified; }
        public void setVerified(boolean verified) { this.verified = verified; }
    }
}