package com.shopmanagement.service;

import com.shopmanagement.entity.Emergency;
import com.shopmanagement.entity.Emergency.EmergencyStatus;
import com.shopmanagement.entity.Emergency.EmergencyType;
import com.shopmanagement.entity.Emergency.EmergencySeverity;
import com.shopmanagement.entity.User;
import com.shopmanagement.repository.EmergencyRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
public class EmergencyService {

    private final EmergencyRepository emergencyRepository;
    private final FirebaseNotificationService firebaseNotificationService;

    @Transactional
    public Emergency createEmergency(User partner, String emergencyType, String description,
                                    Double latitude, Double longitude, String locationAddress) {

        // Check if partner already has active emergency
        if (emergencyRepository.existsByPartnerIdAndStatus(partner.getId(), EmergencyStatus.ACTIVE)) {
            log.warn("Partner {} already has an active emergency", partner.getId());
        }

        // Generate unique emergency ID
        String emergencyId = "EMG" + partner.getId() + "_" + System.currentTimeMillis();

        // Determine severity
        EmergencySeverity severity = getSeverityLevel(emergencyType);

        // Create emergency entity
        Emergency emergency = Emergency.builder()
                .emergencyId(emergencyId)
                .partner(partner)
                .emergencyType(EmergencyType.valueOf(emergencyType.toUpperCase()))
                .status(EmergencyStatus.ACTIVE)
                .severity(severity)
                .description(description)
                .latitude(latitude)
                .longitude(longitude)
                .locationAddress(locationAddress != null ? locationAddress : "Address not available")
                .requiresPolice(requiresPoliceResponse(emergencyType))
                .requiresAmbulance(requiresMedicalResponse(emergencyType))
                .estimatedResponseTime(getEstimatedResponseTime(emergencyType))
                .wasOnDelivery(false) // This should be determined based on partner's current assignment
                .build();

        emergency = emergencyRepository.save(emergency);

        log.error("üö® EMERGENCY CREATED - ID: {}, Partner: {}, Type: {}, Location: {},{}",
                emergency.getEmergencyId(),
                partner.getFirstName() + " " + partner.getLastName(),
                emergencyType, latitude, longitude);

        // Send notifications
        sendEmergencyNotifications(emergency, partner);

        return emergency;
    }

    @Transactional
    public Emergency updateEmergencyStatus(String emergencyId, String newStatus,
                                          String adminNotes, String resolvedBy) {
        Optional<Emergency> emergencyOpt = emergencyRepository.findByEmergencyId(emergencyId);

        if (emergencyOpt.isEmpty()) {
            throw new RuntimeException("Emergency not found: " + emergencyId);
        }

        Emergency emergency = emergencyOpt.get();
        EmergencyStatus previousStatus = emergency.getStatus();
        emergency.setStatus(EmergencyStatus.valueOf(newStatus.toUpperCase()));

        if (adminNotes != null) {
            emergency.setAdminNotes(adminNotes);
        }

        if (newStatus.equals("RESOLVED") || newStatus.equals("CANCELLED")) {
            emergency.setResolvedAt(LocalDateTime.now());
            emergency.setResolvedBy(resolvedBy);

            // Calculate actual response time
            long minutes = ChronoUnit.MINUTES.between(emergency.getCreatedAt(), LocalDateTime.now());
            emergency.setActualResponseTime(minutes + " minutes");
        }

        emergency = emergencyRepository.save(emergency);

        log.info("üìã EMERGENCY STATUS UPDATED - ID: {}, Previous: {}, New: {}",
                emergencyId, previousStatus, newStatus);

        return emergency;
    }

    @Transactional
    public Emergency cancelEmergency(String emergencyId, Long partnerId) {
        Optional<Emergency> emergencyOpt = emergencyRepository.findByEmergencyId(emergencyId);

        if (emergencyOpt.isEmpty()) {
            throw new RuntimeException("Emergency not found: " + emergencyId);
        }

        Emergency emergency = emergencyOpt.get();

        // Verify the emergency belongs to this partner
        if (!emergency.getPartner().getId().equals(partnerId)) {
            throw new RuntimeException("Unauthorized to cancel this emergency");
        }

        emergency.setStatus(EmergencyStatus.CANCELLED);
        emergency.setResolvedAt(LocalDateTime.now());
        emergency.setAdminNotes("Cancelled by driver");

        emergency = emergencyRepository.save(emergency);

        log.info("‚ùå EMERGENCY CANCELLED - ID: {} by Partner: {}", emergencyId, partnerId);

        return emergency;
    }

    public List<Emergency> getPartnerEmergencyHistory(Long partnerId) {
        return emergencyRepository.findByPartnerIdOrderByCreatedAtDesc(partnerId);
    }

    public List<Emergency> getAllActiveEmergencies() {
        return emergencyRepository.findByStatus(EmergencyStatus.ACTIVE);
    }

    public List<Emergency> getEmergenciesNeedingResponse() {
        return emergencyRepository.findEmergenciesNeedingResponse();
    }

    public Map<String, Object> getEmergencyStatistics(Long partnerId) {
        Map<String, Object> stats = new HashMap<>();

        List<Emergency> allEmergencies = emergencyRepository.findByPartnerIdOrderByCreatedAtDesc(partnerId);

        stats.put("totalCount", allEmergencies.size());
        stats.put("activeCount", emergencyRepository.countByPartnerIdAndStatus(partnerId, EmergencyStatus.ACTIVE));
        stats.put("resolvedCount", emergencyRepository.countByPartnerIdAndStatus(partnerId, EmergencyStatus.RESOLVED));
        stats.put("cancelledCount", emergencyRepository.countByPartnerIdAndStatus(partnerId, EmergencyStatus.CANCELLED));

        return stats;
    }

    // Helper methods
    private EmergencySeverity getSeverityLevel(String emergencyType) {
        return switch (emergencyType.toUpperCase()) {
            case "MEDICAL" -> EmergencySeverity.CRITICAL;
            case "ACCIDENT", "ROBBERY" -> EmergencySeverity.HIGH;
            case "VEHICLE_BREAKDOWN", "OTHER" -> EmergencySeverity.MEDIUM;
            default -> EmergencySeverity.MEDIUM;
        };
    }

    private boolean requiresPoliceResponse(String emergencyType) {
        return emergencyType.toUpperCase().equals("ROBBERY") ||
               emergencyType.toUpperCase().equals("ACCIDENT");
    }

    private boolean requiresMedicalResponse(String emergencyType) {
        return emergencyType.toUpperCase().equals("MEDICAL") ||
               emergencyType.toUpperCase().equals("ACCIDENT");
    }

    private String getEstimatedResponseTime(String emergencyType) {
        return switch (emergencyType.toUpperCase()) {
            case "MEDICAL" -> "5-10 minutes";
            case "ACCIDENT" -> "10-15 minutes";
            case "ROBBERY" -> "5-8 minutes";
            case "VEHICLE_BREAKDOWN" -> "20-30 minutes";
            case "OTHER" -> "15-20 minutes";
            default -> "10-15 minutes";
        };
    }

    private void sendEmergencyNotifications(Emergency emergency, User partner) {
        try {
            // Prepare emergency data for notifications
            Map<String, Object> emergencyData = new HashMap<>();
            emergencyData.put("emergencyId", emergency.getEmergencyId());
            emergencyData.put("partnerId", partner.getId());
            emergencyData.put("partnerName", partner.getFirstName() + " " + partner.getLastName());
            emergencyData.put("partnerPhone", partner.getMobileNumber());
            emergencyData.put("emergencyType", emergency.getEmergencyType().name());
            emergencyData.put("severity", emergency.getSeverity().name());
            emergencyData.put("description", emergency.getDescription());
            emergencyData.put("latitude", emergency.getLatitude());
            emergencyData.put("longitude", emergency.getLongitude());
            emergencyData.put("timestamp", emergency.getCreatedAt());

            // Send Firebase notification to admins
            firebaseNotificationService.sendEmergencyNotificationToAdmins(emergencyData);

            // Send WebSocket notification (if implemented)
            // webSocketService.sendEmergencyAlert(emergencyData);

        } catch (Exception e) {
            log.error("Failed to send emergency notifications: {}", e.getMessage());
            // Don't fail the emergency creation if notifications fail
        }
    }

    // Convert Emergency entity to Map for API responses
    public Map<String, Object> convertToMap(Emergency emergency) {
        Map<String, Object> map = new HashMap<>();

        map.put("id", emergency.getId());
        map.put("emergencyId", emergency.getEmergencyId());
        map.put("partnerId", emergency.getPartner().getId());
        map.put("emergencyType", emergency.getEmergencyType().name());
        map.put("status", emergency.getStatus().name());
        map.put("severity", emergency.getSeverity().name());
        map.put("description", emergency.getDescription());
        map.put("latitude", emergency.getLatitude());
        map.put("longitude", emergency.getLongitude());
        map.put("locationAddress", emergency.getLocationAddress());
        map.put("wasOnDelivery", emergency.getWasOnDelivery());
        map.put("orderId", emergency.getOrderId());
        map.put("requiresPolice", emergency.getRequiresPolice());
        map.put("requiresAmbulance", emergency.getRequiresAmbulance());
        map.put("estimatedResponseTime", emergency.getEstimatedResponseTime());
        map.put("actualResponseTime", emergency.getActualResponseTime());
        map.put("timestamp", emergency.getCreatedAt());
        map.put("resolvedAt", emergency.getResolvedAt());
        map.put("resolvedBy", emergency.getResolvedBy());
        map.put("adminNotes", emergency.getAdminNotes());

        // Add driver profile
        User partner = emergency.getPartner();
        Map<String, Object> driverProfile = new HashMap<>();
        driverProfile.put("id", partner.getId());
        driverProfile.put("fullName", (partner.getFirstName() + " " + partner.getLastName()).trim());
        driverProfile.put("profileImageUrl", partner.getProfileImageUrl());
        driverProfile.put("mobileNumber", partner.getMobileNumber());
        driverProfile.put("email", partner.getEmail());
        map.put("driverProfile", driverProfile);

        return map;
    }
}